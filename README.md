# Описание архитектуры и работы приложения "LoginNotifications"

## Основные компоненты и архитектура

Приложение построено на основе архитектурного паттерна **MVVM (Model-View-ViewModel)**, что позволяет разделить логику приложения и представление интерфейса, а также упростить поддержку и тестирование.

- **View** — в `SwiftUI` все представления описаны декларативно. Основные экраны приложения включают:
  - **LoginView**: экран входа, где пользователь вводит логин.
  - **ConfirmationView**: экран подтверждения, где отображается информация о попытке входа и кнопки "Approve" и "Deny" для принятия или отклонения запроса.
  
- **ViewModel** (`LoginViewModel`) — связывает интерфейс (View) с логикой (Model):
  - Отвечает за получение и обработку данных от сервера.
  - Хранит состояния и данные, такие как `loginAttempt`, `showConfirmation`, `requestApproved`, и управляет логикой проверки, отображения и обновления запросов.
  - **Таймер обновлений** запускается для периодической проверки наличия новых запросов входа.

- **Model**:
  - **LoginAttemptModel** и **DecisionModel** — структуры данных, описывающие попытку входа и решение пользователя, соответственно.

## Основные сценарии работы приложения

### 1. Экран входа (LoginView)

- Пользователь вводит логин и нажимает "Войти".
- При нажатии на кнопку вызывается метод `checkLoginAttempt` в `LoginViewModel`:
  - Если для указанного логина есть попытка входа, `loginAttempt` обновляется, и отображается `ConfirmationView`.
  - Если попытки входа нет, отображается пустой экран ожидания с часами, пока не будет создан новый запрос.

### 2. Экран подтверждения (ConfirmationView)

- На `ConfirmationView` отображается информация о попытке входа (логин, браузер, ОС, IP).
- **Кнопки "Approve" и "Deny"**: при нажатии обновляется UI, моментально окрашивая границы круга в зависимости от ответа. Затем:
  - Отправляется POST-запрос с решением на сервер.
  - Через 5 секунд интерфейс очищается и обновляется в режиме ожидания следующего запроса.

### Таймер обновлений

- При переходе на экран `ConfirmationView` запускается таймер, вызывающий метод `checkLoginAttempt` каждые 5 секунд.
- Таймер проверяет наличие новых попыток входа для текущего пользователя и обновляет интерфейс при обнаружении.

## Ключевые классы и методы

1. **LoginViewModel**
   - `checkLoginAttempt()` — проверяет наличие попытки входа и, если она существует, обновляет интерфейс.
   - `submitDecision(approved:)` — отправляет решение (approve/deny) на сервер и обновляет интерфейс.
   - `startCheckingForUpdates()` и `stopCheckingForUpdates()` — управление таймером для периодической проверки новых запросов.

2. **ConfirmationView**
   - `handleDecision(approved:)` — управляет обновлением интерфейса и отправкой решения на сервер.
   - UI динамически обновляется при получении новых данных и изменении состояний.

## Обработка сетевых запросов

- Используется **URLSession** для отправки GET и POST-запросов к серверу.
- Приложение обрабатывает JSON-ответы, обновляя отображение информации о попытке входа и отображение состояния "Approved"/"Denied".


# Описание архитектуры и работы сервера для приложения "LoginNotifications"

## Основные компоненты и архитектура

Сервер написан на **Kotlin с использованием Ktor**, который позволяет легко и быстро создавать REST API. Сервер обрабатывает попытки входа и решения (approve/deny) пользователя, а также возвращает информацию по запросу клиента.

### Основные компоненты

1. **Основные классы данных**:
   - **LoginAttempt**: содержит информацию о попытке входа — логин, браузер, операционная система и IP-адрес.
   - **Decision**: хранит информацию о решении пользователя (approve/deny) для конкретного логина.

2. **Контейнер для хранения данных**:
   - Используется `ConcurrentHashMap` для хранения данных о текущих попытках входа, что обеспечивает поддержку параллельной работы и быструю обработку запросов.

3. **Основные функции**:
   - Извлечение информации о браузере и операционной системе на основе `User-Agent`.
   - Обработка различных типов запросов (`GET`, `POST`) для создания, проверки и отправки решения по попытке входа.

## Основные сценарии работы сервера

### 1. Создание попытки входа (эндпоинт `/createLoginAttempt`)

- Принимает GET-запрос с параметром `login`.
- Определяет IP-адрес пользователя и данные `User-Agent` для определения браузера и операционной системы.
- Создает новый объект `LoginAttempt` и сохраняет его в `loginAttempts` по ключу `login`.
- Возвращает сообщение об успешном создании попытки входа.

### 2. Проверка попытки входа (эндпоинт `/checkLoginAttempt`)

- Принимает GET-запрос с параметром `login`.
- Проверяет наличие попытки входа для данного логина в `loginAttempts`.
- Если попытка найдена, возвращает объект `LoginAttempt` в формате JSON.
- Если попытка не найдена, возвращает сообщение об отсутствии попытки входа.

### 3. Обработка решения пользователя (эндпоинт `/submitDecision`)

- Принимает POST-запрос с объектом `Decision`, содержащим логин и решение пользователя (approve/deny).
- Проверяет наличие попытки входа по логину и удаляет ее после принятия решения.
- Возвращает подтверждение о принятом решении (например, "Login allowed for {login}" или "Login denied for {login}").

## Ключевые функции и логика

1. **Функции для извлечения данных о браузере и операционной системе**:
   - `extractBrowser(userAgent: String): String` — анализирует `User-Agent` и определяет тип браузера.
   - `extractOperatingSystem(userAgent: String): String` — анализирует `User-Agent` и определяет операционную систему.

2. **Контроллеры Ktor**:
   - **GET /createLoginAttempt** — создание и сохранение попытки входа.
   - **GET /checkLoginAttempt** — проверка наличия попытки входа по логину.
   - **POST /submitDecision** — обработка решения пользователя по логину и завершение сессии для этого логина.

3. **Конфигурация Ktor**:
   - `ContentNegotiation` — для JSON-сериализации данных с помощью `kotlinx.serialization`.
   - `CORS` — разрешает запросы с любого источника, необходимый для работы с браузером и Postman.

## Инструкция по тестированию с помощью Postman

### 1. Создание попытки входа
   - **Метод**: GET
   - **URL**: `http://localhost:8080/createLoginAttempt?login={логин}`
   - **Описание**: создает новую попытку входа для указанного логина и сохраняет ее на сервере.

### 2. Проверка попытки входа
   - **Метод**: GET
   - **URL**: `http://localhost:8080/checkLoginAttempt?login={логин}`
   - **Описание**: проверяет, существует ли попытка входа для данного логина. Возвращает JSON-данные или сообщение об отсутствии попытки.

### 3. Отправка решения
   - **Метод**: POST
   - **URL**: `http://localhost:8080/submitDecision`
   - **Тело запроса (JSON)**:
     ```json
     {
       "login": "{логин}",
       "decision": "allow" // или "deny"
     }
     ```
   - **Описание**: отправляет решение (approve/deny) для указанного логина. Удаляет попытку из контейнера `loginAttempts`.

# Инструкция по использованию сервера и приложения "LoginNotifications"

## Описание работы системы

### Сценарий работы

1. **Создание попытки входа**: через Postman (или браузер) отправляется GET-запрос на сервер с указанием логина. Сервер фиксирует попытку входа и сохраняет информацию о логине, IP-адресе и типе браузера.
2. **Проверка на устройстве**: приложение "LoginNotifications" проверяет попытки входа по заданному логину. Если найдена активная попытка входа, приложение отображает её с возможностью "approve" или "deny".
3. **Отправка решения**: в зависимости от выбора пользователя отправляется POST-запрос на сервер с результатом ("approve" или "deny").

## Как настроить и запустить сервер

1. **Настройка сервера**:
   - Убедитесь, что все зависимости указаны правильно в `build.gradle.kts`.
   - Убедитесь, что Gradle и Kotlin настроены для вашей среды разработки.

2. **Запуск сервера**:
   - Выполните команду `./gradlew build` для компиляции проекта.
   - Запустите сервер с командой `./gradlew run` или через среду разработки, например IntelliJ.

3. **Запуск приложения**:
   - Откройте проект в Xcode и запустите его на симуляторе iOS или устройстве.
   - Введите логин и подтвердите вход, приложение автоматически проверит наличие активных попыток входа на сервере.

## Инструкция по использованию Postman для тестирования

### Создание попытки входа

- **Метод**: `GET`
- **URL**: `http://localhost:8080/createLoginAttempt?login={логин}`
- **Описание**: Этот запрос создаёт новую попытку входа на сервере.
  - Например, `http://localhost:8080/createLoginAttempt?login=testUser`
- **Результат**: Сервер ответит сообщением о создании попытки входа, если логин указан.

### Проверка попытки входа

- **Метод**: `GET`
- **URL**: `http://localhost:8080/checkLoginAttempt?login={логин}`
- **Описание**: Этот запрос проверяет наличие активной попытки входа для указанного логина.
- **Результат**: Сервер возвращает информацию о попытке входа в формате JSON или сообщение об отсутствии попытки.

### Отправка решения по попытке входа

- **Метод**: `POST`
- **URL**: `http://localhost:8080/submitDecision`
- **Тело запроса (JSON)**:
  ```json
  {
    "login": "testUser",
    "decision": "allow" // или "deny"
  }


>>>>>>> 6f3b5a8 (READ)
>>>>>>> 6a3f249 (READ)
